---
layout: article
title: "Go基础知识——浮点型"
tags: Go基础知识
aside:
  toc: true
sidebar:
  nav: go-common-release
header:
  theme: dark
  background: 'linear-gradient(135deg, rgb(34, 139, 87), rgb(139, 34, 139))'
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
    src: /docs/assets/images/cover3.jpg
---

参考：

http://golang.iswbm.com/en/latest/c01/c01_03.html
http://c.biancheng.net/view/14.html
https://blog.csdn.net/a451343010/article/details/113848415



转换工具：
进制转换 https://tool.lu/hexconvert/
单精度浮点数转换 http://www.styb.cn/cms/ieee_754.php




[TOC]



### 1. 表示方法

- 浮点数类型的值一般由整数部分、小数点“`.`”和小数部分组成
- 在其中加入指数部分。指数部分由“E”或“e”以及一个带正负号的10进制数组成。比如，`3.7E-2`表示浮点数`0.037`。又比如，`3.7E+1`表示浮点数`37`。

~~~go
const Avogadro = 6.02214129e23  // 阿伏伽德罗常数
const Planck   = 6.62606957e-34 // 普朗克常数
~~~



### 2. 简化表示&fmt标准输出

#### 2.1 简写 

浮点数类型值的表示也可以被简化。比如，`37.0`可以被简化为`37`。又比如，`0.037`可以被简化为`.037`。

~~~go
const e = .71828 // 0.71828
const f = 1.     // 1
~~~

#### 2.3 控制标准化输出保留几位有效数字 

用 Printf 函数打印浮点数时可以使用“%f”来控制保留几位小数：

~~~go
package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Printf("%f\n", math.Pi)
    fmt.Printf("%.2f\n", math.Pi)
}

输出：
3.141593
3.14
~~~



### 3. 浮点类型（float32、float64）在内存中的存储

#### 3.1 二进制表示小数

![图片.png](/assets/images/go-common-release/浮点-1.png)

#### 3.2 转换成以 2 为底的科学计数法

![图片.png](/assets/images/go-common-release/浮点-2.png)

#### 3.3 小结

对于任何数来说，表示成二进制科学计数法后，都成以转换成 **1.xxx（尾数） \* 2 的 n 次方（指数）**

对于小于0的负数来说，则可以表示成 -1.xxx（尾数） * 2 的 n 次方（指数）

=》所以内存中要存储这个小数，则可以拆解成三个部分来存储：

1.   正负号
2.   尾数
3.   指数



#### 3.4 具体存储方式

![图片.png](/assets/images/go-common-release/浮点-3.png)

- 最高位有1bit存储正负号
- 然后指数部分占据8bits（float32）或11bits（float64），**这里存储的结果是实际的指数加上偏移量之后的结果**。这里设置偏移量，是为了让指数部分不出现负数，全都为大于等于0的正整数。
- 其余部分全都用来存储尾数部分。因为二进制的科学计数法，小数点前一定是1开头，因此我们尾数只需要存储小数点后面的部分即可。对于指数部分，



#### 3.5 取值范围 

浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：

- 常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；
- 常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；
- float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。



#### 3.6 浮点精度问题 

这里需要注意到的一点是，比如上图中的十进制小数0.6，表示成二进制后变成了以1001循环的无限循环小数。这便是浮点数有精度问题的根源之一，在代码中声明的小数0.6，计算机底层其实是无法精确存储那个无限循环的二进制数的。只能存入一个零舍一入（类似于十进制的四舍五入）后的近似值。



精度主要取决于尾数部分的位数。

对于 float32（单精度）来说，表示尾数的为23位，除去全部为0的情况以外，最小为2^-23，约等于1.19*10^-7，所以float小数部分只能精确到**小数点后面6位**，加上小数点前的一位，即有效数字为7位。

同理 float64（单精度）的尾数部分为 52位，最小为2^-52，约为2.22*10^-16，所以精确到**小数点后15位**，加上小数点前的一位，有效位数为16位。



#### 3.7 精度实际问题

比如 10000018这个数，用 float32 的类型来表示的话，由于其有效位是7位，将10000018 表示成科学计数法，就是 1.0000018 * 10^7，能精确到小数点后面6位。此时用科学计数法表示后，小数点后有6位，刚刚满足我们的精度要求，意思是什么呢？此时你对这个数进行+1或者-1等数学运算，都能保证计算结果是精确的：

~~~go
import "fmt"
var myfloat float32 = 10000018  //0 10010110 00110001001011010010010  ，转换为二进制1001 1000 1001 0110 1001 0010，正好24位，去掉1.，后面就是23位满足精度要求

func main()  {
    fmt.Println("myfloat: ", myfloat)
    fmt.Println("myfloat: ", myfloat+1)
}

输出：
myfloat:  1.0000018e+07
myfloat:  1.0000019e+07
~~~



上面举了一个刚好满足精度要求数据的临界情况，为了做对比，下面也举一个刚好不满足精度要求的例子。只要给这个数值多加一位数就行了。换成 100000187，同样使用 float32类型，表示成科学计数法，由于精度有限，表示的时候小数点后面7位是准确的，但若是对其进行数学运算，由于第八位无法表示，所以运算后第七位的值，就会变得不精确。

~~~go
import "fmt"

var myfloat01 float32 = 100000182   //0 10011001 01111101011110000110110 ， 因为100000182十进制转换为二进制是1011 1110 1011 1100 0011 0110 110超过了23位
var myfloat02 float32 = 100000187   //0 10011001 01111101011110000110111

func main() {
    fmt.Println("myfloat: ", myfloat01)
    fmt.Println("myfloat: ", myfloat01+5)
    fmt.Println(myfloat02 == myfloat01+5)
}

输出：
myfloat:  1.00000184e+08
myfloat:  1.0000019e+08
false
~~~

**由于精度的问题，就会出现这种很怪异的现象，****`myfloat == myfloat +1`会返回 `true` 。**



### **4. float32详解**

#### **4.1 说明** 

也即我们常说的单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数（算出来减去127，就是指数，表示2的几次方），剩下的23位表示尾数（前面添加一个1.，加上这个尾数）

#### 4.2 示例1 

![图片.png](/assets/images/go-common-release/浮点-4.png) 

符号位0表示正数，指数=124-127=-3 尾数.01，二进制科学计数法表示为1.01*2e-3 = (1*2e1+0*2e-1+1*2e-2)*2e-3 = 1.25*1/8 = 0.15625（十进制）

#### 4.3 示例2 



![图片.png](/assets/images/go-common-release/浮点-5.png)

符号位0表示正数，指数=124-127=-3 尾数.01，二进制科学计数法表示为1.01*2e-3 = (1*2e1+0*2e-1+1*2e-2)*2e-3 = 1.25*1/8 = 0.15625（十进制）



### **5. float64详解**

#### 5.1 说明 

也即我们熟悉的双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数

#### 5.2 示例1 

![图片.png](/assets/images/go-common-release/浮点-6.png)

#### 5.3 示例2

![图片.png](/assets/images/go-common-release/浮点-7.png)





### 6. 总结

- 计算机在存储小数的时候，分为两种类型：

- - 单精度类型（占据32个二进制位，4个字节）
  - 双精度类型（占据64个二进制位，8个字节）

- 双精度类型比单精度类型更能精确地表示一个小数，但是占用的内存空间也比较大。

- 计算机表示一个小数时，先把这个小数转化成以2为底的科学计数法。然后再根据这个数字，把小数拆解成符号位、指数、尾数，存储进内存当中。
